/**
 * @file ir_array.c
 * @author Guilherme Kairalla Kolotelo
 * @author Bruno de Souza Ferreira
 * @version 1.1
 * @date 27 Jun 2016
 * @date 27 Sep 2016
 * @brief File containing the methods for interacting with an IR array .
 */

#include <MKL25Z4.h>
#include "hal/adc/adc.h"
#include "fsl_gpio_hal.h"


void ir_array_initArray()
{
	PORT_Type *irPortBase;
	GPIO_Type *irGpioBase;

	/* Configure enable pins */
	CLOCK_SYS_EnablePortClock(ADC_IR1_EN_PORT_INSTANCE);
	CLOCK_SYS_EnablePortClock(ADC_IR2_EN_PORT_INSTANCE);
	CLOCK_SYS_EnablePortClock(ADC_IR3_EN_PORT_INSTANCE);
	CLOCK_SYS_EnablePortClock(ADC_IR4_EN_PORT_INSTANCE);
	CLOCK_SYS_EnablePortClock(ADC_IR5_EN_PORT_INSTANCE);
	CLOCK_SYS_EnablePortClock(ADC_IR6_EN_PORT_INSTANCE);

	irPortBase = g_portBase[ADC_IR1_EN_PORT_INSTANCE];
	PORT_HAL_SetMuxMode(irPortBase, ADC_IR1_EN_PIN_NUMBER, ADC_EN_PORT_ALT);
	irPortBase = g_portBase[ADC_IR2_EN_PORT_INSTANCE];
	PORT_HAL_SetMuxMode(irPortBase, ADC_IR2_EN_PIN_NUMBER, ADC_EN_PORT_ALT);
	irPortBase = g_portBase[ADC_IR3_EN_PORT_INSTANCE];
	PORT_HAL_SetMuxMode(irPortBase, ADC_IR3_EN_PIN_NUMBER, ADC_EN_PORT_ALT);
	irPortBase = g_portBase[ADC_IR4_EN_PORT_INSTANCE];
	PORT_HAL_SetMuxMode(irPortBase, ADC_IR4_EN_PIN_NUMBER, ADC_EN_PORT_ALT);
	irPortBase = g_portBase[ADC_IR5_EN_PORT_INSTANCE];
	PORT_HAL_SetMuxMode(irPortBase, ADC_IR5_EN_PIN_NUMBER, ADC_EN_PORT_ALT);
	irPortBase = g_portBase[ADC_IR6_EN_PORT_INSTANCE];
	PORT_HAL_SetMuxMode(irPortBase, ADC_IR6_EN_PIN_NUMBER, ADC_EN_PORT_ALT);

	irGpioBase = g_gpioBase[ADC_IR1_EN_GPIO_INSTANCE];
	GPIO_HAL_SetPinDir(irGpioBase, ADC_IR1_EN_PIN_NUMBER, kGpioDigitalOutput);
	GPIO_HAL_ClearPinOutput(irGpioBase, ADC_IR1_EN_PIN_NUMBER);
	irGpioBase = g_gpioBase[ADC_IR2_EN_GPIO_INSTANCE];
	GPIO_HAL_SetPinDir(irGpioBase, ADC_IR2_EN_PIN_NUMBER, kGpioDigitalOutput);
	GPIO_HAL_ClearPinOutput(irGpioBase, ADC_IR2_EN_PIN_NUMBER);
	irGpioBase = g_gpioBase[ADC_IR3_EN_GPIO_INSTANCE];
	GPIO_HAL_SetPinDir(irGpioBase, ADC_IR3_EN_PIN_NUMBER, kGpioDigitalOutput);
	GPIO_HAL_ClearPinOutput(irGpioBase, ADC_IR3_EN_PIN_NUMBER);
	irGpioBase = g_gpioBase[ADC_IR4_EN_GPIO_INSTANCE];
	GPIO_HAL_SetPinDir(irGpioBase, ADC_IR4_EN_PIN_NUMBER, kGpioDigitalOutput);
	GPIO_HAL_ClearPinOutput(irGpioBase, ADC_IR4_EN_PIN_NUMBER);
	irGpioBase = g_gpioBase[ADC_IR5_EN_GPIO_INSTANCE];
	GPIO_HAL_SetPinDir(irGpioBase, ADC_IR5_EN_PIN_NUMBER, kGpioDigitalOutput);
	GPIO_HAL_ClearPinOutput(irGpioBase, ADC_IR5_EN_PIN_NUMBER);
	irGpioBase = g_gpioBase[ADC_IR6_EN_GPIO_INSTANCE];
	GPIO_HAL_SetPinDir(irGpioBase, ADC_IR6_EN_PIN_NUMBER, kGpioDigitalOutput);
	GPIO_HAL_ClearPinOutput(irGpioBase, ADC_IR6_EN_PIN_NUMBER);

	/* Configure ADC pins */
	CLOCK_SYS_EnablePortClock(ADC_IR1_ADC_PIN_NUMBER);
	CLOCK_SYS_EnablePortClock(ADC_IR2_ADC_PIN_NUMBER);
	CLOCK_SYS_EnablePortClock(ADC_IR3_ADC_PIN_NUMBER);
	CLOCK_SYS_EnablePortClock(ADC_IR4_ADC_PIN_NUMBER);
	CLOCK_SYS_EnablePortClock(ADC_IR5_ADC_PIN_NUMBER);
	CLOCK_SYS_EnablePortClock(ADC_IR6_ADC_PIN_NUMBER);

	irPortBase = g_portBase[ADC_IR1_ADC_PORT_INSTANCE];
	PORT_HAL_SetMuxMode(irPortBase, ADC_IR1_ADC_PIN_NUMBER, ADC_ADC_PORT_ALT);
	irPortBase = g_portBase[ADC_IR2_ADC_PORT_INSTANCE];
	PORT_HAL_SetMuxMode(irPortBase, ADC_IR2_ADC_PIN_NUMBER, ADC_ADC_PORT_ALT);
	irPortBase = g_portBase[ADC_IR3_ADC_PORT_INSTANCE];
	PORT_HAL_SetMuxMode(irPortBase, ADC_IR3_ADC_PIN_NUMBER, ADC_ADC_PORT_ALT);
	irPortBase = g_portBase[ADC_IR4_ADC_PORT_INSTANCE];
	PORT_HAL_SetMuxMode(irPortBase, ADC_IR4_ADC_PIN_NUMBER, ADC_ADC_PORT_ALT);
	irPortBase = g_portBase[ADC_IR5_ADC_PORT_INSTANCE];
	PORT_HAL_SetMuxMode(irPortBase, ADC_IR5_ADC_PIN_NUMBER, ADC_ADC_PORT_ALT);
	irPortBase = g_portBase[ADC_IR6_ADC_PORT_INSTANCE];
	PORT_HAL_SetMuxMode(irPortBase, ADC_IR6_ADC_PIN_NUMBER, ADC_ADC_PORT_ALT);

	adc_initAdc();
	// Put all of the above on for's
	// What about pre calibration (Driver method)?
	// Re-do adc library
}



void ir_array_takeMeasurement(uint16_t* uiIrVector)
{
	for(int i = 0; i < 6; i++) uiIrVector[i] = 0;

	adc_startConversion(ADC_IR1_ADC_CH_NUMBER);
	for(int i = 0; i < 50; i++) util_genDelay10ms();
	if(adc_isAdcDone()) uiIrVector[0] = adc_getValue();

	adc_startConversion(ADC_IR2_ADC_CH_NUMBER);
	for(int i = 0; i < 50; i++) util_genDelay10ms();
	if(adc_isAdcDone()) uiIrVector[0] = adc_getValue();

	adc_startConversion(ADC_IR3_ADC_CH_NUMBER);
	for(int i = 0; i < 50; i++) util_genDelay10ms();
	if(adc_isAdcDone()) uiIrVector[0] = adc_getValue();

	adc_startConversion(ADC_IR4_ADC_CH_NUMBER);
	for(int i = 0; i < 50; i++) util_genDelay10ms();
	if(adc_isAdcDone()) uiIrVector[0] = adc_getValue();

	adc_startConversion(ADC_IR5_ADC_CH_NUMBER);
	for(int i = 0; i < 50; i++) util_genDelay10ms();
	if(adc_isAdcDone()) uiIrVector[0] = adc_getValue();

	adc_startConversion(ADC_IR6_ADC_CH_NUMBER);
	for(int i = 0; i < 50; i++) util_genDelay10ms();
	if(adc_isAdcDone()) uiIrVector[0] = adc_getValue();
	// Return all conversions successful (within waiting time)
	// Put all of the above on single for
	// Figure out timing for each conversion
	// Play with faster conversion times and low power mode
}

