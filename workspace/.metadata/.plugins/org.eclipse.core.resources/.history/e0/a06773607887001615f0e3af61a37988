/**
 * @file ir_array.c
 * @author Guilherme Kairalla Kolotelo
 * @author Bruno de Souza Ferreira
 * @version 1.1
 * @date 27 Jun 2016
 * @date 27 Sep 2016
 * @brief File containing the methods for interacting with an IR array .
 */

#include <MKL25Z4.h>
#include "hal/adc/adc.h"
#include "fsl_gpio_hal.h"


void ir_array_initArray()
{
	PORT_Type *irPortBase;
	GPIO_Type *irGpioBase;

	/* Configure enable pins */
	CLOCK_SYS_EnablePortClock(ADC_IR1_EN_PORT_INSTANCE);
	CLOCK_SYS_EnablePortClock(ADC_IR2_EN_PORT_INSTANCE);
	CLOCK_SYS_EnablePortClock(ADC_IR3_EN_PORT_INSTANCE);
	CLOCK_SYS_EnablePortClock(ADC_IR4_EN_PORT_INSTANCE);
	CLOCK_SYS_EnablePortClock(ADC_IR5_EN_PORT_INSTANCE);
	CLOCK_SYS_EnablePortClock(ADC_IR6_EN_PORT_INSTANCE);

	irPortBase = g_portBase[ADC_IR1_EN_PORT_INSTANCE];
	PORT_HAL_SetMuxMode(irPortBase, ADC_IR1_EN_PIN_NUMBER, ADC_EN_PORT_ALT);
	irPortBase = g_portBase[ADC_IR2_EN_PORT_INSTANCE];
	PORT_HAL_SetMuxMode(irPortBase, ADC_IR2_EN_PIN_NUMBER, ADC_EN_PORT_ALT);
	irPortBase = g_portBase[ADC_IR3_EN_PORT_INSTANCE];
	PORT_HAL_SetMuxMode(irPortBase, ADC_IR3_EN_PIN_NUMBER, ADC_EN_PORT_ALT);
	irPortBase = g_portBase[ADC_IR4_EN_PORT_INSTANCE];
	PORT_HAL_SetMuxMode(irPortBase, ADC_IR4_EN_PIN_NUMBER, ADC_EN_PORT_ALT);
	irPortBase = g_portBase[ADC_IR5_EN_PORT_INSTANCE];
	PORT_HAL_SetMuxMode(irPortBase, ADC_IR5_EN_PIN_NUMBER, ADC_EN_PORT_ALT);
	irPortBase = g_portBase[ADC_IR6_EN_PORT_INSTANCE];
	PORT_HAL_SetMuxMode(irPortBase, ADC_IR6_EN_PIN_NUMBER, ADC_EN_PORT_ALT);

	irGpioBase = g_gpioBase[ADC_IR1_EN_GPIO_INSTANCE];
	GPIO_HAL_SetPinDir(irGpioBase, ADC_IR1_EN_PIN_NUMBER, kGpioDigitalOutput);
	GPIO_HAL_ClearPinOutput(irGpioBase, ADC_IR1_EN_PIN_NUMBER);
	irGpioBase = g_gpioBase[ADC_IR2_EN_GPIO_INSTANCE];
	GPIO_HAL_SetPinDir(irGpioBase, ADC_IR2_EN_PIN_NUMBER, kGpioDigitalOutput);
	GPIO_HAL_ClearPinOutput(irGpioBase, ADC_IR2_EN_PIN_NUMBER);
	irGpioBase = g_gpioBase[ADC_IR3_EN_GPIO_INSTANCE];
	GPIO_HAL_SetPinDir(irGpioBase, ADC_IR3_EN_PIN_NUMBER, kGpioDigitalOutput);
	GPIO_HAL_ClearPinOutput(irGpioBase, ADC_IR3_EN_PIN_NUMBER);
	irGpioBase = g_gpioBase[ADC_IR4_EN_GPIO_INSTANCE];
	GPIO_HAL_SetPinDir(irGpioBase, ADC_IR4_EN_PIN_NUMBER, kGpioDigitalOutput);
	GPIO_HAL_ClearPinOutput(irGpioBase, ADC_IR4_EN_PIN_NUMBER);
	irGpioBase = g_gpioBase[ADC_IR5_EN_GPIO_INSTANCE];
	GPIO_HAL_SetPinDir(irGpioBase, ADC_IR5_EN_PIN_NUMBER, kGpioDigitalOutput);
	GPIO_HAL_ClearPinOutput(irGpioBase, ADC_IR5_EN_PIN_NUMBER);
	irGpioBase = g_gpioBase[ADC_IR6_EN_GPIO_INSTANCE];
	GPIO_HAL_SetPinDir(irGpioBase, ADC_IR6_EN_PIN_NUMBER, kGpioDigitalOutput);
	GPIO_HAL_ClearPinOutput(irGpioBase, ADC_IR6_EN_PIN_NUMBER);

	/* Configure ADC pins */
	CLOCK_SYS_EnablePortClock(ADC_IR1_ADC_PIN_NUMBER);
	CLOCK_SYS_EnablePortClock(ADC_IR2_ADC_PIN_NUMBER);
	CLOCK_SYS_EnablePortClock(ADC_IR3_ADC_PIN_NUMBER);
	CLOCK_SYS_EnablePortClock(ADC_IR4_ADC_PIN_NUMBER);
	CLOCK_SYS_EnablePortClock(ADC_IR5_ADC_PIN_NUMBER);
	CLOCK_SYS_EnablePortClock(ADC_IR6_ADC_PIN_NUMBER);

	irPortBase = g_portBase[ADC_IR1_ADC_PORT_INSTANCE];
	PORT_HAL_SetMuxMode(irPortBase, ADC_IR1_ADC_PIN_NUMBER, ADC_ADC_PORT_ALT);
	irPortBase = g_portBase[ADC_IR2_ADC_PORT_INSTANCE];
	PORT_HAL_SetMuxMode(irPortBase, ADC_IR2_ADC_PIN_NUMBER, ADC_ADC_PORT_ALT);
	irPortBase = g_portBase[ADC_IR3_ADC_PORT_INSTANCE];
	PORT_HAL_SetMuxMode(irPortBase, ADC_IR3_ADC_PIN_NUMBER, ADC_ADC_PORT_ALT);
	irPortBase = g_portBase[ADC_IR4_ADC_PORT_INSTANCE];
	PORT_HAL_SetMuxMode(irPortBase, ADC_IR4_ADC_PIN_NUMBER, ADC_ADC_PORT_ALT);
	irPortBase = g_portBase[ADC_IR5_ADC_PORT_INSTANCE];
	PORT_HAL_SetMuxMode(irPortBase, ADC_IR5_ADC_PIN_NUMBER, ADC_ADC_PORT_ALT);
	irPortBase = g_portBase[ADC_IR6_ADC_PORT_INSTANCE];
	PORT_HAL_SetMuxMode(irPortBase, ADC_IR6_ADC_PIN_NUMBER, ADC_ADC_PORT_ALT);

	adc_initAdc();
}



int ir_array_takeMeasurement()
{

}
adc_startConversion();
	for(int i = 0; i < 50; i++)
	{
		util_genDelay10ms();
	}
	if(adc_isAdcDone())
	{
		uint16_t uiTemperature = adc_getValue();
		uiTemperature = HEATER_ADC_TRANSF_EQ_PARAM_A*uiTemperature + HEATER_ADC_TRANSF_EQ_PARAM_B;
		return uiTemperature;
	}
